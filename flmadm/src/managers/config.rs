use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

pub struct ConfigGenerator;

impl ConfigGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Generate default flame-cluster.yaml configuration
    pub fn generate_config(&self, prefix: &Path) -> Result<()> {
        let config_path = prefix.join("conf/flame-cluster.yaml");

        // Check if config already exists
        if config_path.exists() {
            println!(
                "âœ“ Configuration file already exists: {}",
                config_path.display()
            );
            return Ok(());
        }

        println!("ðŸ“ Generating configuration file...");

        let prefix_str = prefix.to_str().unwrap();
        let config_content = self.get_config_template(prefix_str);

        fs::write(&config_path, config_content).context("Failed to write configuration file")?;

        println!("âœ“ Generated configuration: {}", config_path.display());
        Ok(())
    }

    fn get_config_template(&self, prefix: &str) -> String {
        format!(
            r#"# Flame Cluster Configuration
# Generated by flmadm install

# Session Manager Configuration
session_manager:
  endpoint: "http://127.0.0.1:8080"
  storage: "{prefix}/data/sessions.db"
  log_level: "info"

# Executor Manager Configuration
executor_manager:
  endpoint: "http://127.0.0.1:8081"
  work_dir: "{prefix}/work/executors"
  log_level: "info"

# Object Cache Configuration
cache:
  endpoint: "grpc://127.0.0.1:9090"
  network_interface: "lo"
  storage: "{prefix}/data/cache"

# Package Storage Configuration
package:
  storage: "file://{prefix}/data/packages"
  excludes:
    - "*.log"
    - "*.tmp"
    - "*.pyc"
    - "__pycache__"
"#,
            prefix = prefix
        )
    }
}
